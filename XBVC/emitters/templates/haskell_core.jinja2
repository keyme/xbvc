{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# LANGUAGE NamedFieldPuns #-}

module XBVC where

import Bitvec ()
import qualified Cobs
import XBVC.Data

import Control.Concurrent
import qualified Data.ByteString as BS
import Data.IORef
import Data.Word
import qualified Data.Map as Map


type WriteChannel = BS.ByteString -> IO Bool

stopByte :: Word8
stopByte = 0

newDispatcher :: IO Dispatcher
newDispatcher = do
  {% for msg in messages %}
    {{msg.camel_name}} <- newIORef $ standIn "{{msg.camel_name}}"
  {% endfor %}
    decodeErrorFound <- newIORef $ return ()

    return $ Dispatcher {
  {% for line in msg_name_list %}
        {{line}}
  {% endfor %}
        , decodeErrorFound
    }
    where
        standIn str _ msg = do
            putStrLn $ "Message type " ++ str ++ " has no handler: \n\t" ++ (show msg)

newXbvcDispatcher :: IO XBVCDispatcher
newXbvcDispatcher = do
    cbs <- newDispatcher
    rMap <- newMVar mempty
    return $ XBVCDispatcher
                { callbacks = cbs
                , responseMap = rMap
                }


xbvcSend :: XBVCType a
         => WriteChannel
         -> a
         -> Maybe Int
         -> IO Bool
xbvcSend serialChannel msg rID = do
    packet <- xbvcPacket msg rID
    serialChannel $ Cobs.encode $ serialize packet

xbvcSendWithResponse :: (XBVCType a, XBVCType b)
                     => WriteChannel
                     -> XBVCDispatcher
                     -> a
                     -> Maybe Int
                     -> IO (Maybe b)
xbvcSendWithResponse sendChannel dispatcher msg rID = do
    msg <- xbvcPacket msg rID
    let idKey = msgID msg
    let bs = serialize msg
    empMsg <- newEmptyMVar
    modifyMVar_ respMap (return . Map.insert idKey empMsg)
    sent <- sendChannel $ Cobs.encode bs
    resp <- case sent of
        False -> return Nothing
        True -> do
            respMsg <- takeMVar empMsg

            let mPayLoad = payLoad <$> respMsg
            return $ mPayLoad >>= deserialize
    modifyMVar_ respMap (return . Map.delete idKey)
    return resp
    where
        respMap = responseMap dispatcher


dispatch :: XBVCDispatcher -> XBVCPacket -> IO ()
dispatch dispatcher packet =
    if respID packet == 0
        then do
            _ <- forkIO $ call (callbacks dispatcher) packet
            return ()
        else do
            responses <- takeMVar $ responseMap dispatcher
            case Map.lookup (respID packet) responses of
                Nothing -> do
                    putStrLn "Got response for a message we don't remember sending"
                    putStrLn $ "Unexpected response was " ++ (show packet)
                Just mvar -> putMVar mvar (Just packet)
            putMVar (responseMap dispatcher) responses


decodePacket :: BS.ByteString -> Either String XBVCPacket
decodePacket bs = case Cobs.decode bs of
                    Left err -> Left err
                    Right uncobs -> case deserialize uncobs of
                        Nothing -> Left "Bitvec decode error"
                        Just pkt -> Right pkt


processData :: BS.ByteString
       -> XBVCDispatcher
       -> IO (BS.ByteString)
processData pkt dispatcher = do
  case frameEnd of
    False -> return pkt
    True -> do
        case decodePacket pkt of
            Left err -> do
                putStrLn err
                decodeCB <- readIORef $ decodeErrorFound $ callbacks dispatcher
                decodeCB
            Right packet -> dispatch dispatcher packet
        return BS.empty
  where
    frameEnd = if BS.null pkt
               then False
               else ((BS.last pkt) == (0 :: Word8))
