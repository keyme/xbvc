{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# LANGUAGE NamedFieldPuns #-}

module XBVC where

import Bitvec ()
import qualified Cobs
import XBVC.Data

import Control.Concurrent
import qualified Data.ByteString as BS
import Data.IORef
import Data.Word
import qualified Data.Map as Map

stopByte :: Word8
stopByte = 0

newDispatcher :: IO Dispatcher
newDispatcher = do
  {% for msg in messages %}
    {{msg.camel_name}} <- newIORef $ standIn "{{msg.camel_name}}"
  {% endfor %}

    return $ Dispatcher {
  {% for line in msg_name_list %}
        {{line}}
  {% endfor %}
    }
    where
        standIn str _ msg = do
            putStrLn $ "Message type " ++ str ++ " has no handler: \n\t" ++ (show msg)

newXbvcDispatcher :: IO XBVCDispatcher
newXbvcDispatcher = do
    cbs <- newDispatcher
    rMap <- newMVar mempty
    return $ XBVCDispatcher
                { callbacks = cbs
                , responseMap = rMap
                }


xbvcSend :: XBVCType a
         => (BS.ByteString -> IO ())
         -> a
         -> Maybe Int
         -> IO ()
xbvcSend serialChannel msg rID = do
    packet <- xbvcPacket msg rID
    serialChannel $ serialize packet

xbvcSendWithResponse :: (XBVCType a, XBVCType b)
                     => (BS.ByteString -> IO ())
                     -> XBVCDispatcher
                     -> a
                     -> Maybe Int
                     -> IO (Maybe b)
xbvcSendWithResponse sendChannel dispatcher msg rID = do
    msg <- xbvcPacket msg rID
    let idKey = msgID msg
    let bs = serialize msg
    empMsg <- newEmptyMVar
    modifyMVar_ respMap (return . Map.insert idKey empMsg)
    sendChannel $ Cobs.encode bs
    respMsg <- takeMVar empMsg
    modifyMVar_ respMap (return . Map.delete idKey)
    let mPayLoad = payLoad <$> respMsg
    return $ mPayLoad >>= deserialize
    where
        respMap = responseMap dispatcher


dispatch :: XBVCDispatcher -> XBVCPacket -> IO ()
dispatch dispatcher packet =
    if respID packet == 0
        then do
            _ <- forkIO $ call (callbacks dispatcher) packet
            return ()
        else do
            responses <- takeMVar $ responseMap dispatcher
            case Map.lookup (respID packet) responses of
                Nothing -> do
                    putStrLn "Got response for a message we don't remember sending"
                    putStrLn $ "Unexpected response was " ++ (show packet)
                Just mvar -> putMVar mvar (Just packet)
            putMVar (responseMap dispatcher) responses


processData :: BS.ByteString
       -> XBVCDispatcher
       -> IO (BS.ByteString)
processData pkt dispatcher = do
  case frameEnd of
    False -> return pkt
    True -> do
      case Cobs.decode pkt of
        Left err -> do
          putStrLn err
          return BS.empty
        Right bitvec -> do
          case deserialize bitvec of
            Nothing -> putStrLn "Decode error"
            Just packet -> dispatch dispatcher packet
          return BS.empty
  where
    frameEnd = if BS.null pkt
               then False
               else ((BS.last pkt) == (0 :: Word8))
